# Makefile for Prime Server Kubernetes Deployment

.PHONY: help build push deploy test clean status logs shell port-forward scale restart resources setup-local-registry cleanup-local-registry deploy-local deploy-no-push check-registry

# Variables
IMAGE_NAME ?= prime-server
IMAGE_TAG ?= latest
REGISTRY ?= localhost:5000
NAMESPACE ?= default
FULL_IMAGE = $(REGISTRY)/$(IMAGE_NAME):$(IMAGE_TAG)

# Default target
help:
	@echo "üöÄ Prime Server Kubernetes Deployment"
	@echo ""
	@echo "Available targets:"
	@echo "  build              Build Docker image"
	@echo "  push               Push Docker image to registry"
	@echo "  deploy             Deploy to Kubernetes"
	@echo "  deploy-kustomize   Deploy using Kustomize"
	@echo "  deploy-local       Deploy without push (local development)"
	@echo "  deploy-no-push     Build and deploy locally without registry"
	@echo "  deploy-auto        Setup registry + build + push + deploy"
	@echo "  deploy-dockerhub   Quick deploy to Docker Hub"
	@echo "  test               Run deployment tests"
	@echo "  clean              Clean up deployment"
	@echo "  status             Show deployment status"
	@echo "  logs               Show application logs"
	@echo "  shell              Get shell access to pod"
	@echo "  port-forward       Forward local port to service"
	@echo "  scale              Scale deployment"
	@echo "  restart            Restart deployment"
	@echo "  resources          Show resource usage"
	@echo ""
	@echo "Registry Management:"
	@echo "  setup-local-registry    Setup local Docker registry"
	@echo "  cleanup-local-registry  Remove local Docker registry"
	@echo "  check-registry          Test registry connectivity"
	@echo "  test-registry           Full registry functionality test"
	@echo ""
	@echo "Variables:"
	@echo "  IMAGE_NAME=$(IMAGE_NAME)"
	@echo "  IMAGE_TAG=$(IMAGE_TAG)" 
	@echo "  REGISTRY=$(REGISTRY)"
	@echo "  NAMESPACE=$(NAMESPACE)"
	@echo "  FULL_IMAGE=$(FULL_IMAGE)"
	@echo ""
	@echo "Quick Start Examples:"
	@echo "  make setup-local-registry  # Setup local registry"
	@echo "  make deploy-auto          # Complete local deployment"
	@echo "  make deploy-no-push       # Deploy without registry"
	@echo "  DOCKERHUB_USER=user make deploy-dockerhub  # Docker Hub deploy"

# Build Docker image
build:
	@echo "üî® Building Docker image: $(FULL_IMAGE)"
	docker build -t $(FULL_IMAGE) .
	@echo "‚úÖ Build completed"

# Push to registry
push: build
	@echo "üì§ Pushing image: $(FULL_IMAGE)"
	docker push $(FULL_IMAGE)
	@echo "‚úÖ Push completed"

# Deploy using individual manifests
deploy:
	@echo "üöÄ Deploying to Kubernetes..."
	@echo "Creating namespace if not exists..."
	kubectl create namespace $(NAMESPACE) --dry-run=client -o yaml | kubectl apply -f -
	@echo "Applying manifests..."
	kubectl apply -f deployment.yaml -n $(NAMESPACE)
	kubectl apply -f service.yaml -n $(NAMESPACE)
	kubectl apply -f ingress.yaml -n $(NAMESPACE)
	kubectl apply -f autoscaling.yaml -n $(NAMESPACE)
	kubectl apply -f monitoring.yaml -n $(NAMESPACE) || echo "‚ö†Ô∏è Monitoring resources may require Prometheus operator"
	@echo "Waiting for deployment to be ready..."
	kubectl rollout status deployment/prime-server -n $(NAMESPACE) --timeout=300s
	@echo "‚úÖ Deployment completed"

# Deploy using Kustomize
deploy-kustomize:
	@echo "üöÄ Deploying using Kustomize..."
	kubectl apply -k .
	kubectl rollout status deployment/prod-prime-server-v1 -n $(NAMESPACE) --timeout=300s
	@echo "‚úÖ Kustomize deployment completed"

# Full deployment with image build and push
deploy-full: build push deploy
	@echo "‚úÖ Full deployment pipeline completed"

# Test deployment
test:
	@echo "üß™ Testing deployment..."
	@echo "Starting port-forward for testing..."
	kubectl port-forward service/prime-server-service 8080:80 -n $(NAMESPACE) &
	@sleep 5
	@echo "Testing health endpoint..."
	@curl -f http://localhost:8080/health > /dev/null && echo "‚úÖ Health check passed" || (echo "‚ùå Health check failed"; exit 1)
	@echo "Testing API endpoint..."
	@curl -f "http://localhost:8080/primes?count=5" > /dev/null && echo "‚úÖ API test passed" || (echo "‚ùå API test failed"; exit 1)
	@echo "Testing with load..."
	@for i in {1..10}; do \
		curl -s "http://localhost:8080/primes?count=100" > /dev/null & \
	done; wait
	@echo "‚úÖ Load test completed"
	@pkill -f "kubectl port-forward" || true
	@echo "‚úÖ All tests passed"

# Stress test
stress-test:
	@echo "üî• Running stress test..."
	kubectl port-forward service/prime-server-service 8080:80 -n $(NAMESPACE) &
	@sleep 3
	@echo "Running 100 concurrent requests..."
	@seq 1 100 | xargs -n1 -P20 -I{} curl -s "http://localhost:8080/primes?count=50" > /dev/null
	@pkill -f "kubectl port-forward" || true
	@echo "‚úÖ Stress test completed"

# Clean up
clean:
	@echo "üßπ Cleaning up deployment..."
	kubectl delete -f monitoring.yaml -n $(NAMESPACE) || true
	kubectl delete -f autoscaling.yaml -n $(NAMESPACE) || true  
	kubectl delete -f ingress.yaml -n $(NAMESPACE) || true
	kubectl delete -f service.yaml -n $(NAMESPACE) || true
	kubectl delete -f deployment.yaml -n $(NAMESPACE) || true
	@echo "‚úÖ Cleanup completed"

# Clean using Kustomize
clean-kustomize:
	@echo "üßπ Cleaning up using Kustomize..."
	kubectl delete -k . || true
	@echo "‚úÖ Kustomize cleanup completed"

# Show status
status:
	@echo "üìä Deployment Status:"
	@echo ""
	@echo "Pods:"
	kubectl get pods -n $(NAMESPACE) -l app=prime-server -o wide
	@echo ""
	@echo "Services:"
	kubectl get services -n $(NAMESPACE) -l app=prime-server
	@echo ""
	@echo "Deployments:"
	kubectl get deployments -n $(NAMESPACE) -l app=prime-server
	@echo ""
	@echo "HPA:"
	kubectl get hpa -n $(NAMESPACE) -l app=prime-server || echo "No HPA found"
	@echo ""
	@echo "Ingress:"
	kubectl get ingress -n $(NAMESPACE) -l app=prime-server || echo "No Ingress found"

# Show detailed status
status-detailed:
	@echo "üìä Detailed Status:"
	kubectl describe deployment prime-server -n $(NAMESPACE)
	@echo ""
	kubectl describe service prime-server-service -n $(NAMESPACE)

# Show logs
logs:
	@echo "üìã Application logs:"
	kubectl logs -f deployment/prime-server -n $(NAMESPACE) --tail=100

# Show logs from all pods
logs-all:
	@echo "üìã Logs from all pods:"
	kubectl logs -l app=prime-server -n $(NAMESPACE) --tail=50

# Get shell access
shell:
	@echo "üêö Getting shell access..."
	kubectl exec -it deployment/prime-server -n $(NAMESPACE) -- /bin/bash

# Port forward
port-forward:
	@echo "üîó Port forwarding service to localhost:8080"
	@echo "Access the application at: http://localhost:8080"
	@echo "Health check: http://localhost:8080/health"
	@echo "API example: http://localhost:8080/primes?count=10"
	kubectl port-forward service/prime-server-service 8080:80 -n $(NAMESPACE)

# Scale deployment
scale:
	@read -p "Enter replica count: " replicas; \
	echo "üìà Scaling deployment to $$replicas replicas..."; \
	kubectl scale deployment prime-server --replicas=$$replicas -n $(NAMESPACE); \
	kubectl rollout status deployment/prime-server -n $(NAMESPACE)

# Restart deployment
restart:
	@echo "üîÑ Restarting deployment..."
	kubectl rollout restart deployment/prime-server -n $(NAMESPACE)
	kubectl rollout status deployment/prime-server -n $(NAMESPACE)

# Show resources
resources:
	@echo "üíæ Resource Usage:"
	kubectl top pods -n $(NAMESPACE) -l app=prime-server || echo "Metrics server not available"
	@echo ""
	kubectl top nodes || echo "Metrics server not available"

# Watch pods
watch:
	@echo "üëÄ Watching pods..."
	watch kubectl get pods -n $(NAMESPACE) -l app=prime-server

# Show events
events:
	@echo "üìÖ Recent events:"
	kubectl get events -n $(NAMESPACE) --sort-by='.lastTimestamp' | tail -20

# Get pod logs by name
pod-logs:
	@echo "üìã Available pods:"
	@kubectl get pods -n $(NAMESPACE) -l app=prime-server --no-headers | awk '{print $$1}'
	@read -p "Enter pod name: " pod; \
	kubectl logs $$pod -n $(NAMESPACE) -f

# Describe pod
describe-pod:
	@echo "üîç Available pods:"
	@kubectl get pods -n $(NAMESPACE) -l app=prime-server --no-headers | awk '{print $$1}'
	@read -p "Enter pod name: " pod; \
	kubectl describe pod $$pod -n $(NAMESPACE)

# Check resource limits
check-limits:
	@echo "‚ö° Resource limits and requests:"
	kubectl get pods -n $(NAMESPACE) -l app=prime-server -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{range .spec.containers[*]}{"  "}{.name}{": requests="}{.resources.requests}{", limits="}{.resources.limits}{"\n"}{end}{"\n"}{end}'

# Update image
update-image:
	@read -p "Enter new image tag: " tag; \
	echo "üîÑ Updating image to $(REGISTRY)/$(IMAGE_NAME):$$tag"; \
	kubectl set image deployment/prime-server prime-server=$(REGISTRY)/$(IMAGE_NAME):$$tag -n $(NAMESPACE); \
	kubectl rollout status deployment/prime-server -n $(NAMESPACE)

# Rollback deployment
rollback:
	@echo "üîô Rolling back deployment..."
	kubectl rollout undo deployment/prime-server -n $(NAMESPACE)
	kubectl rollout status deployment/prime-server -n $(NAMESPACE)

# Show rollout history
history:
	@echo "üìú Rollout history:"
	kubectl rollout history deployment/prime-server -n $(NAMESPACE)

# Load test using Apache Bench (if available)
load-test-ab:
	@echo "üî• Load testing with Apache Bench..."
	kubectl port-forward service/prime-server-service 8080:80 -n $(NAMESPACE) &
	@sleep 3
	@if command -v ab >/dev/null 2>&1; then \
		ab -n 1000 -c 50 "http://localhost:8080/primes?count=100"; \
	else \
		echo "Apache Bench (ab) not found. Install with: apt-get install apache2-utils"; \
	fi
	@pkill -f "kubectl port-forward" || true

# Check cluster info
cluster-info:
	@echo "üèóÔ∏è Cluster Information:"
	kubectl cluster-info
	@echo ""
	kubectl version --short
	@echo ""
	kubectl get nodes -o wide

# =====================================
# REGISTRY MANAGEMENT TARGETS
# =====================================

# Setup local Docker registry
setup-local-registry:
	@echo "üîß Setting up local Docker registry..."
	@if docker ps | grep -q local-registry; then \
		echo "‚úÖ Local registry already running"; \
	else \
		echo "üöÄ Starting new local registry..."; \
		docker run -d -p 5000:5000 --name local-registry registry:2 || \
		(echo "‚ùå Failed to start registry. Checking if port is in use..." && \
		 docker ps -a | grep local-registry && \
		 echo "üîÑ Removing old registry container..." && \
		 docker rm -f local-registry && \
		 echo "üöÄ Starting fresh registry..." && \
		 docker run -d -p 5000:5000 --name local-registry registry:2); \
	fi
	@sleep 3
	@echo "üîç Testing registry connectivity..."
	@if curl -s http://localhost:5000/v2/ > /dev/null; then \
		echo "‚úÖ Local registry is running at http://localhost:5000"; \
	else \
		echo "‚ùå Registry not responding. Check Docker and try again."; \
	fi

# Cleanup local registry
cleanup-local-registry:
	@echo "üßπ Cleaning up local registry..."
	docker stop local-registry 2>/dev/null || echo "Registry not running"
	docker rm local-registry 2>/dev/null || echo "Registry container not found"
	@echo "‚úÖ Local registry cleanup completed"

# Check registry connectivity
check-registry:
	@echo "üîç Checking registry connectivity: $(REGISTRY)"
	@if curl -s http://$(REGISTRY)/v2/ > /dev/null; then \
		echo "‚úÖ Registry $(REGISTRY) is accessible"; \
	else \
		echo "‚ùå Registry $(REGISTRY) is not accessible"; \
		echo "üí° Try: make setup-local-registry"; \
	fi

# Deploy without pushing (for local development)
deploy-local:
	@echo "üè† Deploying locally without push..."
	@echo "üìù Note: Using imagePullPolicy: Never for local images"
	@echo "Creating namespace if not exists..."
	kubectl create namespace $(NAMESPACE) --dry-run=client -o yaml | kubectl apply -f -
	@echo "Applying manifests with local image policy..."
	@sed 's/imagePullPolicy: IfNotPresent/imagePullPolicy: Never/g' deployment.yaml | kubectl apply -f - -n $(NAMESPACE)
	kubectl apply -f service.yaml -n $(NAMESPACE)
	kubectl apply -f ingress.yaml -n $(NAMESPACE)
	kubectl apply -f autoscaling.yaml -n $(NAMESPACE)
	kubectl apply -f monitoring.yaml -n $(NAMESPACE) || echo "‚ö†Ô∏è Monitoring resources may require Prometheus operator"
	@echo "Waiting for deployment to be ready..."
	kubectl rollout status deployment/prime-server -n $(NAMESPACE) --timeout=300s
	@echo "‚úÖ Local deployment completed"

# Build and deploy without push (complete local workflow)
deploy-no-push: build deploy-local
	@echo "‚úÖ Local build and deploy completed without registry push"

# Deploy with automatic registry setup
deploy-auto: setup-local-registry build push deploy
	@echo "‚úÖ Complete deployment with local registry setup"

# Quick Docker Hub deploy
deploy-dockerhub:
	@echo "üê≥ Quick Docker Hub deployment"
	@if [ -z "$(DOCKERHUB_USER)" ]; then \
		echo "‚ùå Please set DOCKERHUB_USER environment variable"; \
		echo "Example: export DOCKERHUB_USER=yourusername"; \
		exit 1; \
	fi
	@echo "üîê Please ensure you're logged in: docker login"
	$(MAKE) deploy-full REGISTRY=$(DOCKERHUB_USER)

# Test registry with a simple push/pull
test-registry:
	@echo "üß™ Testing registry with hello-world image..."
	docker pull hello-world
	docker tag hello-world $(REGISTRY)/hello-world:test
	docker push $(REGISTRY)/hello-world:test
	docker rmi $(REGISTRY)/hello-world:test
	docker pull $(REGISTRY)/hello-world:test
	docker rmi $(REGISTRY)/hello-world:test
	@echo "‚úÖ Registry test completed successfully"